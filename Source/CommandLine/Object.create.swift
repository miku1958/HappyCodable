//
//  Object.create.swift
//  Pods
//
//  Created by 庄黛淳华 on 2020/7/31.
//

import Foundation
import SourceKittenFramework

private extension Bool {
	func add(_ string: String) -> String {
		self ? "\(string)" : ""
	}
}

extension Array where Element == Object {
	var generatedCode: String {
		guard let definitionObject = self.first(where: { !$0.isExtension }), !definitionObject.accessLevel.isPrivate else { return "" }
		#if DEBUG
		if definitionObject.name.contains("CodingKeysExistStruct") {
			print(1)
		}
		#endif
		let customCodingKeys = self.compactMap {
			$0.customCodingKeys
		}.first
		let propertys = definitionObject.propertys
		let isConfirmToDecodable = self.contains {
			$0.isConfirmToDecodable
		}
		let isConfirmToEncodable = self.contains {
			$0.isConfirmToEncodable
		}
		let inheritedtypes = flatMap {
			$0.inheritedtypes
		}
		let methodNames = flatMap {
			$0.propertys.filter {
				if case let .function(isStatic, _/*content*/) = $0.type, !isStatic {
					return true
				} else {
					return false
				}
			}
		}.map {
			$0.name
		}
		
		var CodingKeys = ""
		var decode = ""
		var encode = ""
		
		func generatedType() {
			var codingKeyCases = ""
			
			var decodingVariables = ""
			
			var encodingVariables = ""
			
			for property in propertys {
				if !property.accessibilitys.contains(.set(accessible: true)) {
					continue
				}
				if property.attributes.contains(.uncoding) {
					continue
				}
				switch property.type {
				case let .instance(isStatic, _/*content*/):
					if isStatic {
						continue
					}
				case .function:
					continue
				case .enumElement:
					continue
				}
				let customCodingKey = customCodingKeys?.first(where: {
					$0.property == property.name
				})
				if customCodingKeys != nil, customCodingKey == nil {
					continue
				}
				var mainKey: String
				if let customCodingKey = customCodingKey {
					mainKey = customCodingKey.key
				} else {
					if let replacingKey = property.replacedKey {
						mainKey = replacingKey
						codingKeyCases += "case \(property.name) = \(replacingKey)"
					} else {
						mainKey = property.name
						codingKeyCases += "case \(property.name)"
					}
					codingKeyCases += "\n"
				}
				mainKey = mainKey.removingQuotes.removingBackQuotes
				
				if isConfirmToDecodable {
					let decodeExpression: String
					if property.alterKeys.isEmpty {
						decodeExpression = "container.decode(key: \"\(mainKey)\")"
					} else {
						decodeExpression =
							"container.decode(key: \"\(mainKey)\", alterKeys: { \(property.alterKeys) })"
					}
					
					let decodeOnly =
						"self.\(property.name) = try \(decodeExpression)"
					
					let decode =
						"do { \(decodeOnly) } catch { \((!property.isOptional).add("errors.append(error)")) }"
					// 这里只能一个一个的do catch, 不能放到同一个do catch里, 不然一个出错后面都不执行了
					
					decodingVariables += "\(decode)\n"
				}
				if isConfirmToEncodable {
					let encodeParameters =
						"(self.\(property.name), forKey: .\(property.name))"
					
					let encodeSafely =
						"do { try container.encodeIfPresent\(encodeParameters) } catch { errors.append(error) }"
					
					encodingVariables += "\(encodeSafely)\n"
				}
			}
			if !codingKeyCases.isEmpty {
				CodingKeys =
					"""
				enum CodingKeys: String, CodingKey {
				\(indent: 1, codingKeyCases)
				}
				"""
			}
			
			decode =
			"""
			\((!definitionObject.isClass).add("mutating"))
			\((definitionObject.accessLevel == .open).add("open"))
			\((definitionObject.accessLevel == .public).add("public"))
			func decode(happyFrom decoder: Decoder) throws {
			\((!codingKeyCases.isEmpty || !(customCodingKeys?.isEmpty ?? true)).add(
				"""
				let container = try decoder.container(keyedBy: StringCodingKey.self)
				var errors = [Error]()
			
				\(methodNames.contains("willStartMapping()").add("self.willStartMapping()"))

			\(indent: 1, decodingVariables)

				\(methodNames.contains("didFinishMapping()").add("self.didFinishMapping()"))

				if !Self.allowHappyDecodableSkipMissing, !errors.isEmpty {
					throw errors
				}
			"""))
			}
			"""
			
			encode =
				"""
			\((definitionObject.accessLevel == .open).add("open"))
			\((definitionObject.accessLevel == .public).add("public"))
			func encode(happyTo encoder: Encoder) throws {
			\((!codingKeyCases.isEmpty || !(customCodingKeys?.isEmpty ?? true)).add(
				"""
				var container = encoder.container(keyedBy: CodingKeys.self)
				var errors = [Error]()

			\(indent: 1, encodingVariables)

				if !Self.allowHappyEncodableSafely, !errors.isEmpty {
					throw errors
				}
			"""))
			}
			"""
		}
		func generatedEnum() {
			var decodings = [String]()
			var encodings = [String]()
			for (_ /*index*/, property) in propertys.enumerated() {
				switch property.type {
				case .function:
					continue
				case .instance:
					continue
				case let .enumElement(content):
					var shortName = property.name
					if let index = shortName.firstIndex(of: "(") {
						shortName = String(shortName[..<index])
					}
					switch content {
					case .type:
						if isConfirmToDecodable {
							let code =
								"""
							case ".\(property.name)":
								self = .\(property.name)
							"""
							decodings.append(code)
						}
						
						if isConfirmToEncodable {
							let code =
								"""
							case .\(property.name):
								try container.encode([".\(property.name)": [String: String]()])
							"""
							encodings.append(code)
						}
						
					case let .function(function):
						if isConfirmToDecodable {
							let code =
								"""
							case ".\(property.name)":
								guard
							\(function.parameters.enumerated().map({ (index, para) -> String in
								let name: String
								if let alterName = para.alterName, alterName != "_" {
									name = alterName
								} else if para.name != "_" {
									name = para.name
								} else {
									name = "$\(index)"
								}
								return """
									let _\(index) = content[name]?["\(name)"]?.data(using: .utf8)
							"""
							}).joined(separator: ",\n"))
								else {
									throw error
								}
								
								self = .\(shortName)(
							\(function.parameters.enumerated().map({ (index, para) -> String in
								let name = para.alterName ?? para.name
								return """
									\((name != "_" && !name.isEmpty).add("\(name): "))try decoder.decode((\(para.type)).self, from: _\(index))
							"""
							}).joined(separator: ",\n"))
								)
							"""
							decodings.append(code)
						}
						
						if isConfirmToEncodable {
							let paras = (0..<function.parameters.count).map({
								"_\($0)"
							}).joined(separator: ", ")
							let code =
								"""
							case let .\(shortName)(\(paras)):
								try container.encode([
									".\(property.name)": [
							\(function.parameters.enumerated().map({ (index, para) -> String in
								let name: String
								if let alterName = para.alterName, alterName != "_" {
									name = alterName
								} else if para.name != "_" {
									name = para.name
								} else {
									name = "$\(index)"
								}
								return """
										"\(name)": String(data: try encoder.encode(_\(index)), encoding: .utf8)
							"""
							}).joined(separator: ",\n"))
									]
								])
							"""
							encodings.append(code)
						}
					}
				}
			}
			decode =
				"""
			\((definitionObject.accessLevel == .open).add("open"))
			\((definitionObject.accessLevel == .public).add("public"))
			init(from decoder: Decoder) throws {
				let container = try decoder.singleValueContainer()
				let content = try container.decode([String: [String: String]].self)
				let error = DecodingError.typeMismatch(\(definitionObject.name).self, DecodingError.Context(codingPath: [], debugDescription: ""))
				guard let name = content.keys.first else {
					throw error
				}
				let decoder = JSONDecoder()
				switch name {
			\(indent: 2, decodings.joined(separator: "\n"))
				default:
					throw error
				}
			}
			"""
			
			encode =
				"""
			\((definitionObject.accessLevel == .open).add("open"))
			\((definitionObject.accessLevel == .public).add("public"))
			func encode(to encoder: Encoder) throws {
				var container = encoder.singleValueContainer()
				let encoder = JSONEncoder()
				switch self {
			\(indent: 2, encodings.joined(separator: "\n"))
				}
			}
			"""
		}
		
		func generatedEnumBaseRawValue() {
			var decodeContent = ""
			
			if !Set(definitionObject.inheritedtypes).intersection(rawRepresentableRawValues).isEmpty {
				decodeContent = "let content: RawValue = try container.decodeSafe()"
			} else {
				decodeContent = "let content = try container.decode(RawValue.self)"
			}
			decode = """
			\((definitionObject.accessLevel == .open).add("open"))
			\((definitionObject.accessLevel == .public).add("public"))
			init(from decoder: Decoder) throws {
				let container = try decoder.singleValueContainer()
			\(indent: 1, decodeContent)
				if let value = \(definitionObject.name)(rawValue: content) {
					self = value
				} else {
					throw DecodingError.typeMismatch(\(definitionObject.name).self, DecodingError.Context(codingPath: [], debugDescription: ""))
				}
			}
			"""
			
			encode =
				"""
			\((definitionObject.accessLevel == .open).add("open"))
			\((definitionObject.accessLevel == .public).add("public"))
			func encode(to encoder: Encoder) throws {
				var container = encoder.singleValueContainer()
				try container.encode(self.rawValue)
			}
			"""
		}
		
		if definitionObject.type == .enum {
			let inheritedtypesSet = Set(inheritedtypes)
			let isRawRepresentable = !inheritedtypesSet.intersection(rawRepresentableRawValues).isEmpty
			let usingRawRepresentable = inheritedtypesSet.contains("RawRepresentable") && self.contains(where: {
				$0.subObjects.contains {
					$0.name == "RawValue"
				}
			})
			
			if isRawRepresentable || usingRawRepresentable {
				generatedEnumBaseRawValue()
			} else {
				generatedEnum()
			}
		} else {
			generatedType()
		}
		
		
		let code =
		"""
		extension \(definitionObject.name) {
		\(indent: 1, CodingKeys)
		\(indent: 1, isConfirmToDecodable.add(decode))
		\(indent: 1, isConfirmToEncodable.add(encode))
		}
		""".replacingOccurrences(of: "\n\n", with: "\n")
		
		return code
	}
}
